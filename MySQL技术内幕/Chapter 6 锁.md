# 锁 

1. 锁

   1. 锁的类型

      * 共享锁（S锁），允许事务读一行数据
      * 排他锁（X锁），允许事务删除或更新一行数据

      ![avatar](./pic/排他锁和共享锁的兼容性.png)  

      为了让事务能够在更细粒度上进行加锁，将锁分为多个层次，成为意向锁。

      在InnoDB里，意向锁即表锁。从粗粒度往细粒度分依次为：

      ​																库 -> 表 -> 页 ->行  

   2. 一致性非锁定读  

      本质就是一行记录有多个版本，当对一行记录进行DML（insert、update、delete）时，DQL（select）不会等待行的X锁的释放，而是去读快照版本里的数据。

      ![avatar](./pic/排他锁和共享锁的兼容性.png)  

      快照是基于undo段完成的，undo本身就是用来做事务回滚的，因此不存在额外开销。

      

      InnoDB中，RC和RR使用非锁定一致性读。但是两个隔离级别对于快照数据定义不一样。

      RC：读已提交，顾名思义，它的mvcc总是会读取最新的那一份快照数据；

      RR：可重复读，只会读当前事务开始时的行数据版本  

   3. 一致性锁定读  

      select ... for update  

      select ... lock in share mode

2. 锁的算法  

   1. 行锁的三种算法  

      + Record Lock：单个行记录上的锁

        总是锁住索引记录，如果没有索引（显式主键也没定义），那就按照隐式主键进行锁定；

      + Gap Lock：间隙锁，锁定一个范围，不包含记录本身

      + Next-Key Lock：Record Lock+Gap Lock，锁范围加本身  

        对于非唯一索引，锁住第一个小于该索引到第一个大于该索引的所对应的行记录

   2. phantom problem（幻象问题）
      Phantom Problem指同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。
      InnoDB采用Next-Key Locking算法避免幻象问题，在RR级别下可以解决。

   

   

