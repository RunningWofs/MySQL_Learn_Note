# Chapter 2 InnoDB存储引擎  

### 2.3 InnoDB体系架构

#### 	  2.3.1 后台线程  

- **Master Thread**

  负责将缓冲池中的数据异步刷新到磁盘，保持数据一致性，包括脏页的刷新、合并插入缓冲、UNDO页回收等；

- **IO Thread**  

  总共有四种类型的IO，read IO, write IO, insert IO, log IO；

- **Purge Thread**

  事务被提交后，其所使用的undolog可能不再需要，因此需要PurgeThread(清理线程)来回收已经使用并分配的undo页；

- **Page Cleaner Thread**

  InnoDB 1.2.X引入，作用是将之前版本的脏页刷新操作放到单独的线程中来完成，目的是减轻原Master Thread的工作及用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能；

  

  *********

  #### 2.3.2 内存

  **1、LRU** 

  InnoDB一般通过LRU算法来管理缓冲池。但是与传统的LRU算法有区别。InnoDB的LRU加入了midpoint的概念，在midpoint之前的列表称为new列表，之后为old列表，这样做的原因是：

  <u>某些sql，比如索引或者数据的扫描操作，会访问表的很多页，甚至是全部页，但这些页通常只在此次查询中使用，如果将这些页都放到链表的头部，有可能会把热点数据从缓存池中去除，导致热点数据下次使用时存储引擎再次访问磁盘。</u>

  

  InnoDB自1.0.X开始有压缩页的概念，压缩页会将原本16kb的页压缩为1kb、2kb、4kb、8kb。		对于这类压缩页，使用压缩列表unzip_LRU来维护。由于表页大小各式各样，使用伙伴算法来分配内存：

  *<u>需要从缓冲池申请4kb页大小</u>*

  1） 检查4kb的unzip_LRU列表，是否有可用页；

  2） 有则使用；

  3） 无则检查8kb的unzip_LRU列表；

  4） 将获得的内存分为两个4kb的页，存放到4kb的LRU列表去维护；

  5） 都没有则从16kb的LRU获取一个页，将页分为一个8kb和两个4kb，分别存入相应列表维护；

  

  LRU页被修改后，该页成为脏页（缓冲区的页和磁盘上页的数据产生不一致）。此时数据库通过checkpoint机制将脏页刷新回磁盘

  

  **2、重做日志缓冲**

  **3、额外内存**



### 2.4 CheckPoint技术

