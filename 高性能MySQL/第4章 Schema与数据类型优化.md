### **1、选择存储类型的简单原则**

- 更小的通常更好
- 简单就好（整形比字符操作代价更低；应该使用MySQL内建类型来存储时间而不是字符；应该使用整形来存储IP地址）
- 尽量避免Null（含有Null值会让MySQL的优化更困难，而且为Null的列需要更多的存储空间，当可为Null的列被索引时，每一个索引都需要一个额外的字节）；
  建立索引的列应尽量避免设计为可为Null



### **2、datetime和timestamp区别**

相同点：都能存储相同类型的数据：时间和日期，精确到秒。

不同点：timestamp只占用datetime一半的存储空间，并且他会随时区进行变化，具有特殊的自动更新能力的。但是，timestamp允许的时间范围比datetime要小的多，这点要注意



### **3、数据类型**

**1）整数类型**

有5种类型：tinyint(8bit)、smallint(16bit)、mediumint(24bit)、int(32bit)、bigint(64bit)，存储-2<sup>N-1</sup>到2<sup>N-1</sup>-1，N为存储空间位数；

整数类型有可选的unsigned属性，不允许负值，表达范围大致使整数大一倍；

MySQL可以为整数类型设置宽度，如INT(11)，但其实这对大部分应用是没有任何意义的：它不会限制值的合法范围，只是规定了某些交互工具如MySQL命令行客户端的显示字符个数。<u>就存储和计算来讲，INT(1)和INT(20)没卵区别</u>



**2）实数类型**  

float（32bit，7个有效位）、double（64bit，15个有效位）、decimal（128bit，28个有效位）

ps：浮点型计算存在丢失精度，因此，如果所需精度比较小而且数值范围允许，可以考虑将原生数据乘以10<sup>n</sup>，使用bigint存储，避免计算带来的精度丢失



**3）字符串类型**  

**1. varchar和char**

varchar：

varchar是变长字符存储类型，5.0之前支持最大长度255<u>字节</u>，5.0开始支持最大长度65535<u>字符</u>。

由于varchar是变长的，因此需要1到2字节存储记录字符串的长度，255以内就是一字节，以上就是两字节。

因为可变长，所以要注意行变长时所带来的页存储空间不足的情况；

适用varchar的情况：

- 字符串列的最大长度比平均长度大很多；
- 列更新少，碎片存储问题不大；
- 使用utf-8等复杂字符集，不同字符存储的字节数不同；



char：

char会删除数据末尾所有空格；



<u>虽然varchar是变长的，定义varchar(5)和varchar(200)在存储小于等于5个字符时空间开销一样，但是，这里的空间开销仅针对磁盘空间。当MySQL将数据读到内存进行操作时，分配的内存块是根据定义的长度来分配的，因此更长的列会消耗更多内存，在内存中进行排序或者操作时性能没有短列的好</u>



**2. BLOB和TEXT**

都是存储很大的数据的字符串类型，BLOB存储二进制，TEXT存储字符。

排序方式与其他类型不同，只能对最前max_sort_length字节进行排序，不能对全部长度的字符串进行索引。



因为Memory引擎不支持BLOB和TEXT类型。因此，如果查询涉及到了BLOB或TEXT列并且需要使用隐式临时表，是不得不使用MyISAM磁盘临时表的，即使数据量只有几行。这样会有性能问题。最好的办法是避免使用这两种类型的字符串数据类型，实在没有办法的话，可以在使用到这两个类型的查询中使用substring(column, length)，截取足够小的长度，就可以使用内存临时表



**3.日期和时间类型**

datetime:

8字节存储，精度为秒，存储格式为YYYYMMDDHHmmss的整形，无时区划分

timestamp:

4字节存储，精度为秒，存储的是时间戳，按时区划分



**4.位数据类型**

bit：

bit的存储行为根据存储引擎不同而不同。MyISAM会打包存储所有的bit列，但是InnoDB和memory会为Bit列使用一个足够存储的最小整数类型来存放，不会节省存储空间。

MySQL是把bit类型当做字符串类型处理的，因此检索时是当做ascii码来获得检索结果，如b'001110011'检索出来的是字符码为57的字符串，即'9'。但是在数字上下文应用场景下，会转换成数字57，这点要注意。

